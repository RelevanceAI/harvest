# Migration Plan: Daytona + Claude Agent SDK Integration

## Overview

**Goal**: Replace Modal executor with Daytona sandboxes running Claude Agent SDK (`@anthropic-ai/claude-agent-sdk`) to enable proper agentic features (interrupts, queries, session management) while solving the root user restriction.

**Why Daytona**:
- Runs as non-root user (`/home/user`) - no `--dangerously-skip-permissions` blocking
- ~90-200ms cold starts with snapshots
- Already integrated in relevance-api-node (GitHub Coder pattern)
- Volume support, Python SDK, auto-stop/archive

**Why Claude Agent SDK**:
- Bundles Claude Code CLI internally (works with OAuth tokens)
- Proper message types: SystemMessage, AssistantMessage, ToolUseMessage, ToolResultMessage
- Interrupt handling (abort signals, graceful cancellation)
- Session management (pause/resume, context preservation)
- TypeScript types for all interactions

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Relevance Platform                            │
├─────────────────────────────────────────────────────────────────┤
│  relevance-chat-app                                              │
│  ├── HarvestToolViewer (NEW)                                     │
│  │   ├── Renders Claude SDK message types                        │
│  │   ├── Shows file edits, tool calls, thinking                  │
│  │   └── Handles streaming output                                │
│  └── toolDisplayMapping.ts → harvest: HarvestToolViewer          │
├─────────────────────────────────────────────────────────────────┤
│  relevance-api-node                                              │
│  ├── HarvestRuntime (NEW)                                        │
│  │   ├── Creates/manages Daytona sandbox                         │
│  │   ├── Spawns Claude Agent SDK session                         │
│  │   └── Maps SDK messages → Relevance conversation              │
│  ├── harvestAgent (NEW preset agent)                             │
│  └── Interrupt handling via AbortController                      │
├─────────────────────────────────────────────────────────────────┤
│  Daytona Sandbox                                                 │
│  ├── harvest-snapshot (NEW)                                      │
│  │   ├── Node.js 20 + @anthropic-ai/claude-agent-sdk             │
│  │   ├── Python 3.11 + uv                                        │
│  │   ├── Git, ripgrep, MCP servers                               │
│  │   └── Non-root user: /home/user                               │
│  └── Claude Agent SDK session running inside sandbox             │
└─────────────────────────────────────────────────────────────────┘
```

---

## Tasks

### Task 0: POC - SDK Invocation & Output Format (BLOCKER RESOLUTION)

**Purpose**: Validate critical assumptions before building full implementation.

**Location**: `packages/daytona-executor/poc/` (CREATED)

**What to validate**:

1. **SDK can be invoked via Daytona sandbox.process.exec()**
   - Does the SDK start correctly?
   - Does it require PTY/interactive shell?
   - What environment variables are needed?

2. **SDK output format is parseable**
   - Is output structured JSON/JSONL?
   - What message types appear?
   - How are tool calls represented?
   - How is streaming handled?

3. **OAuth token works via env var**
   - Can we pass `ANTHROPIC_API_KEY` or need OAuth-specific var?
   - Does token get logged anywhere?

**POC Script**:
```typescript
import { Daytona } from "@daytonaio/sdk";

async function testSDKInvocation() {
  const daytona = new Daytona();

  // Create minimal sandbox
  const sandbox = await daytona.create({
    image: "node:20-slim",  // Start minimal, not full snapshot
    envVars: {
      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
    },
  });

  try {
    // Install SDK
    await sandbox.process.exec("npm install -g @anthropic-ai/claude-agent-sdk");

    // Attempt invocation with simple prompt
    const result = await sandbox.process.exec(
      'claude --print "Hello, respond with just OK"'
    );

    console.log("=== STDOUT ===");
    console.log(result.stdout);
    console.log("=== STDERR ===");
    console.log(result.stderr);
    console.log("=== EXIT CODE ===");
    console.log(result.exitCode);

    // Analyze output format
    try {
      const parsed = JSON.parse(result.stdout);
      console.log("=== PARSED JSON ===");
      console.log(JSON.stringify(parsed, null, 2));
    } catch {
      console.log("Output is NOT JSON - raw text");
    }

  } finally {
    await sandbox.stop();
  }
}

testSDKInvocation();
```

**Success criteria**:
- [ ] SDK starts without errors
- [ ] Output format is documented
- [ ] Token authentication works
- [ ] No PTY requirement blocking exec()

**If POC fails**:
- Document the failure mode
- Investigate alternatives (PTY support in Daytona, different SDK invocation)
- May need to pivot architecture

---

### Task 1: Create Daytona Snapshot

**Location**: `packages/daytona-executor/` (replaces `packages/modal-executor/`)

**Files to create**:
```
daytona/
├── Dockerfile
├── devcontainer.json
└── README.md
```

**Dockerfile contents**:
```dockerfile
FROM node:20-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    git \
    curl \
    ripgrep \
    python3.11 \
    python3-pip \
    && rm -rf /var/lib/apt/lists/*

# Install uv for Python package management
RUN curl -LsSf https://astral.sh/uv/install.sh | sh

# Install Claude Agent SDK globally
RUN npm install -g @anthropic-ai/claude-agent-sdk

# Install common MCP servers
RUN npm install -g \
    @anthropic-ai/claude-code \
    @modelcontextprotocol/server-github \
    @anthropic-ai/mcp-server-memory

# Create non-root user (Daytona handles this but be explicit)
RUN useradd -m -s /bin/bash user
USER user
WORKDIR /home/user

# Set up environment
ENV PATH="/home/user/.local/bin:$PATH"
```

**devcontainer.json**:
```json
{
  "name": "harvest-sandbox",
  "build": {
    "dockerfile": "Dockerfile"
  },
  "remoteUser": "user",
  "workspaceFolder": "/home/user/workspace"
}
```

**Success criteria**:
- [ ] Snapshot builds successfully in Daytona
- [ ] `claude-agent-sdk` command available
- [ ] Running as `user` (not root)
- [ ] MCP servers installed and accessible

---

### Task 2: HarvestRuntime Backend Integration

**Location**: `relevance-api-node/apps/nodeapi/src/agent/preset_agents/harvest/`

**Files to create**:
```
harvest/
├── agent.ts          # PresetAgent definition
├── runtime.ts        # HarvestRuntime (manages Daytona + SDK)
├── message-mapper.ts # SDK messages → Relevance conversation
├── types.ts          # TypeScript types for SDK messages
└── README.md
```

**runtime.ts pattern** (based on ComputerRuntime):
```typescript
import { Daytona } from "@daytonaio/sdk";
import { Session, type Message } from "@anthropic-ai/claude-agent-sdk";

const HARVEST_SNAPSHOT = "harvest-snapshot";

export const HarvestRuntime = async (convo: ConversationManager) => {
  const daytona = new Daytona();

  // Get or create sandbox
  let sandbox = await getOrCreateSandbox(convo, daytona);

  // Create Claude Agent SDK session inside sandbox
  const session = await createClaudeSession(sandbox, {
    model: "claude-sonnet-4-20250514",
    systemPrompt: buildSystemPrompt(convo),
    tools: getEnabledTools(convo),
    extendedThinking: true,  // Enabled by default
  });

  // Stream messages back to Relevance conversation
  for await (const message of session.messages) {
    await mapMessageToConversation(message, convo);
  }

  // Handle completion
  await handleSessionComplete(session, convo);
};
```

**Key implementation details**:
1. Use `sandbox.process.exec()` to spawn SDK session
2. Stream stdout/stderr back through message mapper
3. Handle AbortController for interrupts
4. Map SDK message types to Relevance tool calls

**Success criteria**:
- [ ] HarvestRuntime creates Daytona sandbox with harvest-snapshot
- [ ] Claude Agent SDK session starts inside sandbox
- [ ] Messages stream back to Relevance conversation
- [ ] Sandbox auto-stops after idle timeout

---

### Task 3: SDK Message → Relevance Conversation Mapping

**Location**: `harvest/message-mapper.ts`

**SDK Message Types to handle**:
```typescript
type SDKMessage =
  | SystemMessage      // → Add as system context
  | AssistantMessage   // → Stream as assistant response
  | ToolUseMessage     // → Create tool_call in conversation
  | ToolResultMessage  // → Create tool_result in conversation
  | ResultMessage      // → Final response with metadata
  | ThinkingMessage    // → Stream as thinking block (if enabled)
```

**Mapping logic**:
```typescript
async function mapMessageToConversation(
  message: SDKMessage,
  convo: ConversationManager
): Promise<void> {
  switch (message.type) {
    case "assistant":
      await convo.streamAssistantMessage(message.content);
      break;

    case "tool_use":
      await convo.addToolCall({
        id: message.id,
        name: message.name,
        input: message.input,
      });
      break;

    case "tool_result":
      await convo.addToolResult({
        tool_call_id: message.tool_use_id,
        output: message.content,
        is_error: message.is_error,
      });
      break;

    case "thinking":
      await convo.streamThinking(message.thinking);
      break;

    case "result":
      await convo.complete({
        cost_usd: message.usage?.cost,
        tokens: message.usage?.total_tokens,
      });
      break;
  }
}
```

**Success criteria**:
- [ ] All SDK message types correctly mapped
- [ ] Streaming works (not just batched)
- [ ] Tool calls appear in chat UI
- [ ] Thinking blocks render (if extended thinking enabled)

---

### Task 4: Interrupt Handling

**Location**: `harvest/runtime.ts` (integrated with HarvestRuntime)

**Implementation**:
```typescript
export const HarvestRuntime = async (convo: ConversationManager) => {
  const abortController = new AbortController();

  // Register interrupt handler with Relevance
  convo.onInterrupt(() => {
    abortController.abort();
  });

  // Pass to SDK session
  const session = await createClaudeSession(sandbox, {
    signal: abortController.signal,
    // ...other options
  });

  // Handle graceful shutdown
  session.on("abort", async () => {
    await convo.addSystemMessage("Task interrupted by user");
    await sandbox.stop();
  });
};
```

**Success criteria**:
- [ ] User can interrupt running task from chat UI
- [ ] Interrupt propagates to SDK session
- [ ] Sandbox stops cleanly (no orphaned processes)
- [ ] Conversation reflects interrupted state

---

### Task 5: HarvestToolViewer Frontend Component

**Location**: `relevance-chat-app/src/components/ToolDisplay/HarvestToolViewer/`

**Files to create**:
```
HarvestToolViewer/
├── index.tsx              # Main component
├── FileEditView.tsx       # Renders file diffs
├── ToolCallView.tsx       # Renders tool invocations
├── ThinkingView.tsx       # Renders thinking blocks
├── TerminalOutputView.tsx # Renders bash output
└── types.ts               # Props types
```

**Main component**:
```typescript
export const HarvestToolViewer: React.FC<HarvestToolViewerProps> = ({
  message,
  toolCalls,
}) => {
  // Determine which sub-component to render based on tool type
  switch (message.tool_name) {
    case "edit_file":
    case "write_file":
      return <FileEditView {...message} />;

    case "bash":
      return <TerminalOutputView {...message} />;

    case "thinking":
      return <ThinkingView {...message} />;

    default:
      return <ToolCallView {...message} />;
  }
};
```

**Register in toolDisplayMapping.ts**:
```typescript
export const agentToolDisplayMap = {
  // ...existing mappings
  harvest: {
    // Map specific tools to components
    edit_file: FileEditView,
    write_file: FileEditView,
    bash: TerminalOutputView,
    // Default fallback
    _default: ToolCallView,
  } as AgentToolsMapping<"harvest">,
};
```

**Success criteria**:
- [ ] File edits show as diffs
- [ ] Bash output renders with syntax highlighting
- [ ] Thinking blocks collapsible
- [ ] Tool calls show name, input, output
- [ ] Streaming updates smoothly

---

### Task 6: PresetAgent Definition

**Location**: `harvest/agent.ts`

```typescript
import { PresetAgent, PresetAgentIds } from "../preset_agent";
import { HarvestRuntime } from "./runtime";

const relevance_config = {
  // Agent configuration for Relevance platform
  name: "Harvest",
  description: "Autonomous coding agent powered by Claude",
  icon: "harvest-icon",
};

export const harvestAgent = new PresetAgent({
  id: PresetAgentIds.harvest,  // Add: harvest = "harvest" to enum
  Run: HarvestRuntime,
  relevance_config,
  relevance_only: true,
  display_in_chat: true,
});

// No bashExecTool needed - SDK handles all tools internally
// Just expose control tools
harvestAgent.addTool(createComputerTool);  // Create/manage sandbox
harvestAgent.addTool(interruptTool);        // Interrupt running task
```

**Success criteria**:
- [ ] Agent appears in Relevance agent list
- [ ] Can be invoked from chat
- [ ] Sandbox lifecycle managed correctly

---

### Task 7: Testing & Validation

**Test scenarios**:

1. **Basic execution**
   - [ ] Start Harvest agent with simple task
   - [ ] Verify sandbox creates with correct snapshot
   - [ ] Verify Claude SDK session starts
   - [ ] Verify messages stream to chat

2. **Tool usage**
   - [ ] File read/write/edit tools work
   - [ ] Bash execution works
   - [ ] MCP tools available (GitHub, memory)
   - [ ] Tool results display correctly

3. **Interrupts**
   - [ ] Interrupt mid-task
   - [ ] Verify graceful shutdown
   - [ ] Verify sandbox stops
   - [ ] Verify conversation state correct

4. **Edge cases**
   - [ ] Long-running task (>5 min)
   - [ ] Large file edits
   - [ ] Network errors
   - [ ] Sandbox timeout/auto-stop

5. **OAuth flow**
   - [ ] Verify OAuth token passed to SDK
   - [ ] Verify no root permission issues
   - [ ] Verify session creation works

---

## Dependencies

**NPM packages**:
- `@anthropic-ai/claude-agent-sdk` - Core SDK
- `@daytonaio/sdk` - Daytona integration (already in relevance-api-node)

**External services**:
- Daytona cloud account
- Anthropic API access (OAuth)
- GitHub token (for MCP server)

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| SDK API changes | High | Pin version, monitor releases |
| Daytona cold starts slow | Medium | Pre-warm pool, snapshot optimization |
| Message mapping incomplete | Medium | Start with core types, iterate |
| Interrupt race conditions | Medium | Test thoroughly, graceful timeouts |
| OAuth token expiry | Low | Relevance handles refresh |

---

## Rollout Plan

1. **Phase 1**: Daytona snapshot + basic runtime (no frontend)
2. **Phase 2**: Message mapping + TerminalView fallback
3. **Phase 3**: HarvestToolViewer with rich displays
4. **Phase 4**: Interrupt handling + edge cases
5. **Phase 5**: Production rollout

---

## Success Metrics

- Cold start time < 500ms (with snapshot)
- Message latency < 100ms (streaming)
- Interrupt response < 1s
- Zero permission-related failures
- Feature parity with original Modal POC

---

## Resolved Questions

1. **Snapshot repo**: Add to this repo (`packages/modal-executor/` → `packages/daytona-executor/`) - Modal doesn't work
2. **PresetAgentIds**: `harvest` (matches pattern: `github`, `patch`, `slides`)
3. **Extended thinking**: Enabled by default
4. **Cost tracking**: SDK provides `result.usage.total_cost_usd` and `result.modelUsage` - see below

### Cost Tracking Implementation

The SDK returns usage data on the result message:

```typescript
// From SDK result
interface SDKResult {
  usage: {
    input_tokens: number;
    output_tokens: number;
    cache_creation_input_tokens: number;
    cache_read_input_tokens: number;
    total_cost_usd: number;  // ← Use this for billing
  };
  modelUsage: Record<string, {
    input_tokens: number;
    output_tokens: number;
    // Per-model breakdown
  }>;
}

// In message mapper
case "result":
  await convo.complete({
    cost_usd: message.usage.total_cost_usd,
    input_tokens: message.usage.input_tokens,
    output_tokens: message.usage.output_tokens,
    model_usage: message.modelUsage,
  });
  break;
```

Sources:
- [Tracking Costs and Usage - Claude Docs](https://platform.claude.com/docs/en/agent-sdk/cost-tracking)
- [Usage and Cost API - Claude Docs](https://platform.claude.com/docs/en/build-with-claude/usage-cost-api)

---

## Adversarial Review (Gemini)

### BLOCKERS - Must Address Before Implementation

#### 1. OAuth Token Security
**Problem**: Passing OAuth token as environment variable is insecure - other sandbox processes could access it.

**Resolution**: Use Daytona's secrets management. The existing GitHub Coder pattern in `common_runtimes.ts` already handles this:
```typescript
// Secrets are injected via Daytona's secure secret storage
const sandbox = await daytona.create({
  envVars: {
    // Daytona encrypts these at rest and in transit
    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
  },
});
```

**Action**: Verify Daytona secrets are encrypted and not logged. Consider short-lived tokens if long-lived poses risk.

#### 2. SDK Output Format Verification
**Problem**: Assuming stdout is structured JSON without verifying could break message mapping.

**Resolution**: Need POC to verify SDK output format before building message mapper.

**Action**: Add **Task 0: SDK Output Format POC** - invoke SDK in Daytona sandbox and capture raw output.

#### 3. sandbox.process.exec() Compatibility
**Problem**: SDK may require interactive shell or specific environment that exec() doesn't provide.

**Resolution**: Need POC to verify SDK runs correctly via exec().

**Action**: Add **Task 0: SDK Invocation POC** - verify SDK starts and produces output via exec().

### SHOULD Address

#### 4. MCP Servers Scope
**Problem**: Including unnecessary MCP servers bloats snapshot and increases cold start.

**Resolution**: Only include essential servers:
- `@modelcontextprotocol/server-github` - Required for repo operations
- `@anthropic-ai/mcp-server-memory` - Required for persistent memory

Remove any others. Document why each is needed.

#### 5. Session Persistence
**Problem**: No pause/resume means every interaction cold starts.

**Resolution**: Investigate Daytona warm pools and SDK state serialization. Add to Task 7 testing.

#### 6. AbortController Reliability
**Problem**: Signal propagation may not work reliably across all scenarios.

**Resolution**: Implement timeout fallback - if SDK doesn't respond to abort within 5s, forcefully terminate sandbox.

#### 7. Comprehensive Testing
**Problem**: "Basic testing" is insufficient for production.

**Resolution**: Expand Task 7 with:
- Performance testing (cold start, streaming latency)
- Resilience testing (network interruptions, SDK crashes)
- Security testing (token handling, sandbox isolation)
- Load testing (concurrent sessions)

### CONSIDER

#### 8. Error Handling & Logging
Add structured logging for debugging:
- Sandbox lifecycle events
- SDK invocation success/failure
- Message mapping errors
- Interrupt handling

#### 9. Snapshot Versioning
Use semantic versioning for snapshots (e.g., `harvest-snapshot:1.0.0`). Enable rollback.

#### 10. Resource Limits
Configure Daytona sandbox limits:
- CPU: 2 cores
- Memory: 4GB
- Disk: 10GB
- Timeout: 30 minutes

---

## Updated Task Order

Based on blockers, new task order:

1. **Task 0: POC** (NEW) - Verify SDK invocation and output format
2. Task 1: Daytona Snapshot
3. Task 2: HarvestRuntime
4. Task 3: Message Mapping
5. Task 4: Interrupt Handling
6. Task 5: HarvestToolViewer
7. Task 6: PresetAgent
8. Task 7: Testing (expanded)
