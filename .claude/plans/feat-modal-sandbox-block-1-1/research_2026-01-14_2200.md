# Modal Sandbox Infrastructure Research
**Date**: 2026-01-14
**Phase**: 1.1 - Foundation
**Block**: Modal Sandbox Infrastructure
**Status**: COMPLETE

---

## Executive Summary

Modal AI platform is **well-suited for Harvest's AI agent sandbox environment**. Key findings:

- ✅ **Sandboxes**: Perfect for arbitrary code execution (core requirement for AI-generated code)
- ✅ **Volumes**: Persistent storage for shared state between executions
- ✅ **Scheduling**: Cron-based job scheduling for 30-min environment refresh
- ✅ **Cost-effective**: Pay-per-use (~$0.0008 per 30-sec execution, no idle costs)
- ✅ **Fast deployment**: Docker-compatible image building, <2s cold starts
- ⚠️ **Constraint**: 24-hour max Sandbox lifetime (manageable with snapshots)

---

## Research Areas & Findings

### 1. Container & Image Management

**Modal Approach**:
- Native builder: Chain methods on `modal.Image.debian_slim()` or base images
- Dockerfile support: Full compatibility with `modal.Image.from_dockerfile()`
- Registry support: Public (Docker Hub, ECR, GCR) and private registries with Secrets

**Base Image Options**:
- `debian_slim(python_version="3.x")` - Recommended for minimal footprint
- `micromamba()` - For conda/mamba workflows
- Custom registry images with Modal method chaining

**Refresh Strategy**:
- Automatic: Only rebuild when definition changes (method-by-method layer caching)
- Force rebuild: `force_build=True` or `MODAL_FORCE_BUILD=1` env var
- Optimization: Put frequently-changing layers last (requirements.txt, git clones)

**Cost**: No explicit storage charges; only compute time during builds

### 2. Execution Model (Core for AI)

**Sandboxes** (Recommended for our use case):
- Full container control: Run arbitrary commands with `sb.exec()`
- Long-lived: Up to 24 hours (can extend via snapshots)
- Perfect for: AI-generated code execution without type constraints
- Pattern: Create → Execute → Snapshot (optional) → Terminate

**Functions** (Not recommended for AI agent):
- Stateless, type-safe serialization
- Single input per execution
- Better for deterministic, bounded workloads

**Concurrency**:
- Each Sandbox is single-tenant
- Multiple concurrent Sandboxes via `Sandbox.create()` in parallel
- No special concurrency configuration needed for Sandboxes

**Performance**:
- Cold start: ~1s (container bootstrap) + <2s (image pull)
- Typical initialization: 2-5s total
- Optimization: Move heavy setup to image build time or use snapshots

### 3. Storage & State Management

**Volumes** (Persistent across Sandboxes):
- `modal.Volume.from_name()` with mount point
- Performance: 2.5 GB/s bandwidth
- Limits (v1): Max 500K inodes, ~5 concurrent writers
- Operations: `commit()` persists, `reload()` fetches latest
- Cost: Included in storage (no explicit charges)

**Sandbox Filesystem Snapshots**:
```python
image = sb.snapshot_filesystem()  # Capture current state
sb2 = modal.Sandbox.create(image=image)  # Restore from snapshot
```
- Use case: Save initialized environments for faster subsequent runs
- Reduces cold-start overhead (skip setup steps)

**Recommendation for Harvest**:
- Volumes for shared state (shared libraries, downloaded models, git repos)
- Snapshots for post-initialization environment state
- Regular commits to persist changes

### 4. Scheduling

**Cron Support**:
- Unix crontab syntax with timezone support
- Example: `modal.Cron("*/30 * * * *")` for every 30 minutes
- Limitations:
  - Only works on deployed apps (need `modal deploy`)
  - Each invocation independent execution
  - No guaranteed execution time
  - Starter plan: 5 crons max; Team plan: unlimited

**For 30-min refresh**:
```python
@app.function(schedule=modal.Cron("*/30 * * * *"), retries=3)
def refresh_environment():
    # Rebuild images, update dependencies, etc.
    pass
```

**Retry logic**: Exponential backoff available via `retries=N`

### 5. Authentication & Secrets

**Setup**:
- CLI: `modal setup` creates local credentials in `~/.modal`
- CI/CD: Service users with tokens via `MODAL_TOKEN_ID` and `MODAL_TOKEN_SECRET` env vars

**Secrets Management**:
- Dashboard-managed (templates provided)
- CLI: `modal secret create name KEY=value`
- Programmatic: `modal.Secret.from_dict()` or `from_dotenv()`
- Attached to functions/Sandboxes via `secrets=[...]` parameter

### 6. Cost Model

**Compute Pricing**:
- CPU: $0.0000131/core/sec (~$0.47/hour per core)
- Memory: $0.00000222/GiB/sec (~$0.08/hour per GiB)
- Minimum: 0.125 cores + 0.25 GiB

**Sandbox Pricing** (slightly higher):
- CPU: $0.00003942/core/sec (~$1.42/hour per core)
- Memory: $0.00000672/GiB/sec (~$0.24/hour per GiB)

**GPU** (if needed):
- T4: ~$0.59/hour
- L4: ~$0.80/hour
- A10, H100, H200: Higher prices

**Free Tier**:
- Starter plan: $30/month free credits
- Team plan: $100/month free credits
- Covers significant usage for dev/testing

**Typical Cost for AI Sandbox** (30-sec execution, 0.5 cores, 1 GiB RAM):
- Per run: ~$0.0008 (~0.08 cents)
- 1000 runs/day: ~$0.80/day = ~$24/month
- Only pay for execution time, not idle

### 7. Key Gotchas & Limitations

**Critical for Implementation**:
1. **24-hour max Sandbox lifetime**: Workaround with snapshots
2. **Volume reloads unmount**: Plan commits carefully
3. **Image layer caching aggressive**: Need explicit `force_build=True` for frequent updates
4. **Sandbox naming per-app**: Use `object_id` for persistent references
5. **Crons only on deployed apps**: Requires `modal deploy` (not development mode)
6. **Volumes v1 limited to 500K inodes**: Use v2 (beta) for many temp files
7. **No external registry storage**: Build directly from code (faster but no external export)

### 8. Recommended Architecture Pattern

```python
# Base image with common dependencies
base_image = modal.Image.debian_slim(python_version="3.11") \
    .apt_install("git", "curl", "build-essential") \
    .uv_pip_install("requests", "numpy", "pandas")

# Shared state volume
shared_vol = modal.Volume.from_name("agent-state", create_if_missing=True)

# Periodic refresh of environment
@app.function(schedule=modal.Cron("*/30 * * * *"), retries=3)
def refresh_environment():
    pass

# Main entry point: create sandbox for each agent execution
def execute_agent_code(code: str):
    sb = modal.Sandbox.create(
        image=base_image,
        volumes={"/mnt/shared": shared_vol},
        timeout=3600,
        app=app
    )
    try:
        result = sb.exec("python", "-c", code, timeout=1800)
        return result
    finally:
        sb.terminate()
```

---

## Comparison to Alternatives

| Aspect | Modal | AWS EC2 | AWS Lambda | Self-Hosted Docker |
|--------|-------|---------|------------|-------------------|
| Idle costs | ❌ None | ⚠️ Always running | ❌ None | ⚠️ Always running |
| Max runtime | ✅ 24h | ✅ Unlimited | ❌ 15 min | ✅ Unlimited |
| Arbitrary code | ✅ Yes | ✅ Yes | ❌ Limited | ✅ Yes |
| Scaling | ✅ Auto | ⚠️ Manual | ✅ Auto | ❌ Manual |
| Setup time | ✅ Minutes | ⚠️ Hours | ✅ Minutes | ⚠️ Hours |
| Cold start | ✅ 1s | ⚠️ 1-2 min | ❌ 5-10s | ⚠️ Variable |
| File system | ✅ Yes | ✅ Yes | ⚠️ Limited | ✅ Yes |

**Verdict**: Modal is best fit for our use case.

---

## Key Documentation References

- [Image Building](https://modal.com/docs/guide/images)
- [Sandboxes](https://modal.com/docs/guide/sandboxes) - Core feature
- [Volumes](https://modal.com/docs/guide/volumes) - Persistent storage
- [Scheduling (Cron)](https://modal.com/docs/guide/cron)
- [Secrets Management](https://modal.com/docs/guide/secrets)
- [Sandbox Snapshots](https://modal.com/docs/guide/sandbox-snapshots)
- [Pricing](https://modal.com/pricing)
- [Cold Start Optimization](https://modal.com/docs/guide/cold-start)

---

## Next Steps

✅ Research complete. Ready to create detailed implementation plan.

Key decision points for plan:
1. Base image configuration (Python version, key dependencies)
2. Volume organization (directory structure for shared state)
3. Snapshot strategy (when to save, when to restore)
4. Refresh job design (what to update every 30 min)
5. Test harness approach (how to verify sandbox creation/execution)
